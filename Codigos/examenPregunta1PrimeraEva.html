<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*Vives en una ciudad, donde todas las calles están dispuestas en una cuadrícula perfecta.
Llegas unos minutos antes a una cita, así que decides aprovechar la oportunidad para dar un
corto paseo.
La ciudad ofrece a sus ciudadanos una aplicación para móviles (en realidad la haremos en
JavaScript), generadora de caminatas: cada vez que la ejecutas, proporcionas un número (los
minutos que tienes libres) y recibes una secuencia de letras que representan la dirección en la
que te debes dirigir durante cada minuto ('n' de norte, 's' de sur, 'o' de oeste, 'e' de este) .
Siempre caminas solo una manzana por cada letra (dirección) y sabes que te lleva un minuto
atravesar una manzana de la ciudad.
Crea una función tal que, proporcionándole el tiempo del que dispones en minutos, obtenga
una cadena de letras (tantas como minutos dispongas) que te permitirá pasear y volver al
punto inicial exactamente en los minutos introducidos (¡no quieres ni llegar temprano ni
retrasarte!).
Nota: siempre recibirás una matriz no vacía válida que contiene una secuencia aleatoria de
letras de dirección. Por ejemplo [“n”, ”e”, ”n”, ”o”, ”s”, ”o”, ”s”, ”s” ,”e” ,”n”] para diez
minutos
La aplicación debe funcionar para tiempos comprendidos entre 6 y 16 minutos
Simula el resultado con una petición de 8 minutos y otra de 12.
El programa solo funciona con numeros pares
En el dibujo adjunto se representa gráficamente la secuencia (no válida) “nonnees” */

let TIEMPO;//definimos tiempo
do{//usamos un bucle do-while para el control de datos porque este es el unico bucle que se inicia al menos una vez
    TIEMPO = parseInt(prompt("Dame un tiempo entre 6 y 16, ambos incluidos"));
    if(isNaN(TIEMPO)){//Ponemos el fallo de noInt antes que de los pares
        window.alert("No admito letras como tiempo");
    }

    else if(TIEMPO%2 !=0){
        window.alert("Solo funciono con tiempos pares");
    }

    else if((TIEMPO < 6 || TIEMPO >16)){//Si el tiempo es menor a 6 o mayor a 16...
        window.alert("Solo funciono con tiempos entre 6 y 16 minutos");//mensaje de fallo
    }

    
}while ((TIEMPO < 6 || TIEMPO > 16) || isNaN(TIEMPO) || TIEMPO%2 !=0);//El bucle se repite mientras no demos un dato correcto o no proporcionemos un numero


console.log(calculaRuta(TIEMPO));//Si superamos el bucle pasamos el tiempo a la función que va a calcular la ruta


function calculaRuta(TIEMPO){

    let paseoIda = [];//array vacio para guardar el recorrido de ida
    let paseoVuelta = [];//array para guardar el recorrido de vuelta
    let paseoCompleto = [];//array que tendrá todo el recorrido

    for(let i=0; i<TIEMPO/2; i++){//Vamos a calcular solo la primera mitad del paseo. La segunda mitad será la vuelta
        let direccion = Math.ceil(Math.random()*4);//En cada iteracion del bucle direccion tomará un valor de 1 a 4

        if(direccion == 1){//si la direccion es 1...
            paseoIda.push("n");//mete un n en el array
        }

        else if(direccion == 2){//si la direccion en 2...
            paseoIda.push("s");//mete s en el array
        }

        else if(direccion == 3){//si la direccion en 3...
            paseoIda.push("e");//mete e en el array
        }

        else if(direccion == 4){//si la direccion en 4...
            paseoIda.push("e");//mete e en el array
        }
    }


        //Vamos a recorrer el array formado
        for(let i=0;i<paseoIda.length;i++){
            //Vamos a ir metiendo las direcciones contraias en el segundo array

            if(paseoIda[i]=="n"){
                paseoVuelta.push("s");
            }
            else if(paseoIda[i]=="s"){
                paseoVuelta.push("n");
            }
            else if(paseoIda[i]=="e"){
                paseoVuelta.push("o");
            }
            else if(paseoIda[i]=="o"){
                paseoVuelta.push("e");
            }

        }

        //ahora metemos el recorrido de ida y vuelta en el array de paseo final
        paseoCompleto = paseoIda.concat(paseoVuelta);
        return paseoCompleto;
}

    </script>
</body>
</html>
